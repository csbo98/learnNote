  // 对同一个文件多次fopen会怎么样？效果如同多次open，使用如下代码验证在kernel 5.10和glibc上验证结果，
  // 发现三个流对应不同的文件描述符，那么操作的效果和使用open是一样的

  //  FILE* fd1 = fopen("test_open.cpp", "r");
  //  FILE* fd2 = fopen("test_open.cpp", "r");
  //  FILE* fd3 = fopen("test_open.cpp", "w");
  //  printf("%d ---- %d --- %d", fd1->_fileno, fd2->_fileno, fd3->_fileno);
  
  // 多次open又会怎么样？会返回多个不同的fd，而且每一个fd完全独立，就像多个进程读写同一文件一样，这种情况下需要
  // 使用记录锁来保证互斥操作

  // 多线程使用C\C++的文件流读写同一个文件时，是一定要加锁的，因为有一个多线程共享的用户态的缓冲区。多线程直接使用
  // open等系统调用来操纵文件同样是需要加锁的，有偏移量等共享资源。

  // 综上所述，文件IO的最佳实践是：多线程对单一文件的读写使用互斥锁等互斥机制来保证互斥操作；多进程对单一文件的读写使用
  // 记录锁来保证进程之间的互斥操作。