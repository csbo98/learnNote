在多线程并发执行，修改同一个变量的过程中，因为操作系统的调度，有可能使得多线程的执行结果是错误的。

这是因为，高级语言中，每一条语句都不是原子操作，可能是有多条机器指令组成的。我们的程序逻辑体现在高级语言当中（如果高级语言程序都是原子操作，那么OS怎么调度都不会影响程序的正确性），而操作系统可能不会按照高级语言的逻辑来调度各个并发执行的线程。

可能会出现线程t1读取了某个值，还没有来得及写回到内存中，就被OS阻塞。然后t2读取了该值，进行操作。这样一来就会导致错误的结果。最简单的示例是两个线程并发执行语句x = x + 1；最后的结果小于预期。


使用互斥锁等锁，本质上是保证在任何一个时刻都只有一个线程能够访问共享变量，保证了多线程程序的正确性，但是降低了并发度。

