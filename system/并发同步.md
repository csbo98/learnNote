# thread

在多线程并发执行，修改同一个变量的过程中，因为操作系统的调度，有可能使得多线程的执行结果是错误的。

这是因为，高级语言中，每一条语句都不是原子操作，可能是有多条机器指令组成的。我们的程序逻辑体现在高级语言当中（如果高级语言程序都是原子操作，那么OS怎么调度都不会影响程序的正确性），而操作系统可能不会按照高级语言的逻辑来调度各个并发执行的线程。

可能会出现线程t1读取了某个值，还没有来得及写回到内存中，就被OS阻塞。然后t2读取了该值，进行操作。这样一来就会导致错误的结果。最简单的示例是两个线程并发执行语句x = x + 1；最后的结果小于预期。

使用互斥锁等锁，本质上是保证在任何一个时刻都只有一个线程能够访问共享变量，保证了多线程程序的正确性，但是降低了并发度。

缓存一致性是关于内存与cache之间的一致性，与这里的并发问题没有太大的关系，在多核处理器上执行时并发问题与单核相似

感觉应该把原子操作理解为：针对该变量的某个操作，要么全部执行完要么全部不执行，而且在某个执行流执行该操作时别的执行流不能执访问或修改该变量。 [这个wiki也是这样解释的](https://wiki.osdev.org/Atomic_operation)

## 核心原则

当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，需要对这些线程进行同步，确保他们在访问变量的存储内容时不会访问到无效的值。

## 并发同步

进程之间同步可以通过信号量来实现，尤其是在进程之间需要通过共享内存来共享数据的时候需要用信号量来控制；进程之间通过消息队列和管道通信的时候不需要额外的同步机制。进程内线程之间主要是用锁来实现同步，包括：互斥锁、自旋锁、读写锁、条件变量以及屏障等。

可重入锁：可重入锁是指同一个线程可以多次获得同一个锁，而不会造成死锁。可重入锁的实现方法有很多，比如在锁结构中增加一个计数器，每次获得锁的时候计数器加1，释放锁的时候计数器减1，当计数器为0的时候才真正释放锁。一般情况下，绝不使用可重入锁。

**自旋锁**不涉及到上下文切换和OS的调度，但会浪费CPU时间。所以适用于线程持有锁时间比较短的情况，一般在用户态不会使用自旋锁。**自旋锁可以用于锁被持有的时间短，而且线程并不希望在重新调度上话费太大的成本。**

[锁的解释与总结](https://www.zhihu.com/question/66733477)

## Python中的锁

在Python中，原始锁(应该对应与一般的互斥锁)是一个在锁定时不属于特定线程的同步基元组件；而递归锁对象(也叫可重入锁)是一个可以被同一个线程多次获取的同步基元组件，在内部，它在原始锁的锁定和非锁定状态上附加了“所属线程”和“递归等级”的概念。可以借助这两个概念理解可重入锁。
