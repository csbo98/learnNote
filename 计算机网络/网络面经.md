# 网络面经



## select、poll、epoll

三种技术通常与非阻塞IO同时使用，但是也可以与阻塞式IO一起使用。**select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。**

### 区别

1. select默认情况下最多只能监听1024个文件描述符，而且**描述符集合既是入参，同时也是出参**。poll和epoll没有文件描述符数量的限制。**select使用固定长度的BitMap表示文件描述符集合，默认情况下最多监听0-1023的描述符。**
2. poll每次检测之后的结果**不会修改原来的传入值**，而是把结果保留在revents字段中，因此不需要每次检测完都重置待检测的描述符和感兴趣的事件。**poll使用动态数组存储描述符、没有select所具有的文件描述符数量限制，只会受到系统的文件描述符数量的限制。**，epoll能够监听的文件描述符上限是进程可以打开的最大文件描述符个数。
3. poll和select在内核中的实现本质上是相似的，**都是使用「线性结构」存储进程关注的 socket 集合，因此都需要在用户态和内核态分别遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合**
4. **epoll避免了用户态 - 内核态频繁的数据拷贝，大大提高了系统性能**；最关键的一点是摒弃了select和poll那种拷贝文件描述符集合的思路，select和poll的缺陷在于其在内核没有维护描述符集合的数据结构。然后epoll避免用户态和内核态频繁拷贝的利器是红黑树，每一个epoll实例对应一棵内核中的红黑树，用来存储待检测的描述符集合，这样就能够使用O(logn)的时间复杂度向内核中的epoll实例增加、删除和修改文件描述符以及其上感兴趣的事件。select和poll的可扩展性很差，随着描述符数量的增加，CPU时间也会显著增加，而epoll则具有很好的可扩展性，处理10个描述符的CPU开销和处理10000个描述符的时间开销相差不大，而且远低于select和poll。
5. epoll相比于select和poll性能更好的原因有两点，一是避免了用户态和内核态大量的数据拷贝；二是用户态不需要轮询整个描述符集合，提高了检测效率。

### epoll

在非阻塞IO的前提下，epoll边缘触发模式需要持续的读数据，一直读到EAGAIN；accept同样需要持续的从队列取出新的连接直到EAGAIN。「If the socket is marked nonblocking and no pending connections are the queue, accept() fails with the error EAGAIN or EWOULDBLOCK.」

传说中，epoll的边缘触发方式比水平触发方式效率更高，理由是边缘触发可以减少epoll_wait的系统调用次数。

epoll在总的连接数量很多，但是活跃连接数量很少的情况下效率会比poll和select高很多。
