# 事务并发控制

事务的隔离性指的是事务之间操作的可见性，那么隔离级别反应的就是事务之间的可见性级别。事务之间不同的隔离级别能够解决事务并发执行时所导致的不同的问题。事务并发执行导致的三个典型问题是：脏读（读到了别的事务尚未提交的数据）、不可重复读（在同一个事务中，对同一个记录的两次不同的读操作读到的是不同的数据）、幻读（在同一个事务中，两次执行相同的查询操作，但是读取到的记录的数量不一致）。

事务的隔离性主要通过加锁和基于时间戳（包括mvcc）的方法来实现，事务的隔离级别包括：读未提交（read uncommitted）、读已提交（read committed）、可重复读（repeatable read）、串行化（serializable）。他们的隔离性逐渐增强，也即数据的一致性逐渐增强，但是并发性逐渐降低。

READ COMMITED(RC)表示只能读取到已经提交的数据，通过MVCC实现，**事务中的每个查询语句都单独构建一个ReadView**。

SERIALIZABLE一般情况下是通过锁机制来实现。

REPEATABLE READ：在事务中多次读取同一记录，都会返回第一次查询的快照，返回完全相同的数据行，其核心的实现机制是基于MVCC实现，**事务中的第一个SELECT语句执行时，会将当前系统中所有的活跃事务拷贝到一个列表中生成ReadView，事务中后续的SELECT操作复用其之前生成的ReadView**。

## MVCC与ReadView

MVCC主要是**通过保存数据在某个时间点的快照**来实现并发控制，在MVCC中，**只有写写之间会相互阻塞**，其他的操作都可以并行。Postgres在数据行上实现多版本，而InnoDB在undolog中实现多版本，可以通过undolog找回数据的历史版本。

对RC和RR的ReadView创建可以做一个对比：在RR中，只有第一条SELECT生成ReadView前，已经提交的事务的修改可见；在RC中，每一条SELECT都可以看到其他已经提交的事务对数据的修改，只要事务提交，其结果对其它事务的SELECT都是可见的，与事务开始的先后顺序无关。



## log

**undo log**可以用来做事务的回滚操作，保证事务的原子性；同时也可以用来**构建记录被修改之前的版本**， 用于支持多版本读。 





## 事务四大特性

1. 原子性：可以通过undolog来实现
2. 持久性：通过redolog来实现，保证commit的数据一定不会丢失
3. 隔离性：指的是多个事务可以同时对数据进行修改，但是相互不影响。通过加锁或者MVCC实现。



## Two-phase locking

是数据库中一个用于保证可串行化的并发控制方法，有不同的变种，基础版本和部分变种可能会导致死锁





















