# thread

在多线程并发执行，修改同一个变量的过程中，因为操作系统的调度，有可能使得多线程的执行结果是错误的。

这是因为，高级语言中，每一条语句都不是原子操作，可能是有多条机器指令组成的。我们的程序逻辑体现在高级语言当中（如果高级语言程序都是原子操作，那么OS怎么调度都不会影响程序的正确性），而操作系统可能不会按照高级语言的逻辑来调度各个并发执行的线程。

可能会出现线程t1读取了某个值，还没有来得及写回到内存中，就被OS阻塞。然后t2读取了该值，进行操作。这样一来就会导致错误的结果。最简单的示例是两个线程并发执行语句x = x + 1；最后的结果小于预期。

使用互斥锁等锁，本质上是保证在任何一个时刻都只有一个线程能够访问共享变量，保证了多线程程序的正确性，但是降低了并发度。

缓存一致性是关于内存与cache之间的一致性，与这里的并发问题没有太大的关系，在多核处理器上执行时并发问题与单核相似

感觉应该把原子操作理解为：针对该变量的某个操作，要么全部执行完要么全部不执行，而且在某个执行流执行该操作时别的执行流不能执访问或修改该变量。 [这个wiki也是这样解释的](https://wiki.osdev.org/Atomic_operation)

## 核心原则

当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，需要对这些线程进行同步，确保他们在访问变量的存储内容时不会访问到无效的值。

## 并发同步

进程之间同步可以通过信号量来实现，尤其是在进程之间需要通过共享内存来共享数据的时候需要用信号量来控制；进程之间通过消息队列和管道通信的时候不需要额外的同步机制。进程内线程之间主要是用锁来实现同步，包括：互斥锁、自旋锁、读写锁、条件变量以及屏障等。

**自旋锁**不涉及到上下文切换和OS的调度，但会浪费CPU时间。所以适用于线程持有锁时间比较短的情况，一般在用户态不会使用自旋锁。

[锁的解释与总结](https://www.zhihu.com/question/66733477)
