# shell

## 命令执行过程

在shell中执行程序(比如执行一个python或者pip命令)时，首先要查找该程序(或者命令)的路径(os会搜索一个目录列表找到跟命令同名的可执行文件，目录列表存在一个叫PATH的环境变量里面)，这是为了找到该程序的可执行文件，从而在fork子进程之后exec该程序的内容到新创建的进程中，从而才能执行该程序。

所以在执行程序时，要么给出该程序的路径，要么让shell可以找得到该程序的路径。对于一个程序如果不给出该程序的路径，那么shell会按照顺序查找PATH环境变量中的各个目录，找到之后就执行对应的程序。PATH中的目录是从左往右搜索的，所以目录列表中开头目录中匹配到的可执行文件优于另外一个。

所以为了直接输入程序名字而不用输入路径，可以使用两种方法：

1. 把该程序所在的目录放入PATH环境变量中；
2. 把该程序可执行文件或者是符号连接放入到PATH环境变量中已有目录中的任何一个，这个是为什么很多程序编译之后执行make install命令就可以直接使用程序名字而不需要输入程序路径。

Unix系统上面的任何命令都是一个普通的用户程序，比如echo、ls等，shell执行它们的方法与执行自己的普通程序一样。

Python中的subprocess模块创建子进程的思路和“fork-exec”相似，但是把这个过程封装起来了，调用时只需要传入程序的路径和参数。subprocess模块启动子进程时，传入的参数只能来自一个文件，而不能是一个函数。这个模块可以调用任何shell命令，比如ls等（这些都是C程序，那自己写一个C程序应该也能这样用），在参数列表里面指定“shell = True”会把对应的命令传递给shell去处理；

在shell脚本中，默认情况下，命令都是按照顺序执行的，前面的命令执行完成才能执行后面的命令(这一点与在shell中只能有一个前台命令很相似)；

如果给命令加了&，让其在后台执行，那么多个命令是可以并行执行的。命令尾部加了&之后，启动的进程就会变成“后台任务”，它的特点是继承当前session的标准输出(stdout)和标准错误(stderr),所以，后台任务的输出依然同步的在命令行下显示；不在继承当前session的标准输入(stdin)。所以，“后台任务”与前台任务的区别只有一个：是否继承标准输入。所以，执行后台任务的同时，用户还可以输入其他命令。

## 内置命令

shell内置命令都是在运行shell进程的内部执行的。
